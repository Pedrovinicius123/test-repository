# test-repository

##Epilogue

An idea I've got

I'm higly suspecting that there is no algorithm that solves a 3-SAT (and forward) problem efficiently, most of the problems have a high time complexity in worst case.
But i have to prove that for *all* problems we have are contained in the worst case. There's a graph that determine it.

![P_neq_NP](https://github.com/user-attachments/assets/14a41604-99a4-4e7b-bfca-8f27e9c8ee61)

 According to [this source](https://www-sciencedirect-com.translate.goog/topics/computer-science/combinatorial-problem): "Combinatorial problems arise in many areas of computer science and other disciplines in which computational methods are applied, such as artificial intelligence, operations research, bioinformatics and electronic commerce. Prominent examples are tasks such as finding shortest or cheapest round trips in graphs, finding models of propositional formulae or determining the 3D-structure of proteins. Other well-known combinatorial problems are encountered in planning, scheduling, time-tabling, resource allocation, code design, hardware design and genome sequencing. These problems typically involve finding groupings, orderings or assignments of a discrete, finite set of objects that satisfy certain conditions or constraints."

 That may be disapointing, but I think that is the right answer: $P \neq NP$. More studies must be done to ensure that. Although, it is very sad for me that this may be true...
 
